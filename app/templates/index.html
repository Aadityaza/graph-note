<!DOCTYPE html>
<html>
  <head>
    <title>Dashboard</title>
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='style.css') }}"
    />

    <script src="https://d3js.org/d3.v6.min.js"></script>

    <script
      src="https://code.jquery.com/jquery-3.7.1.min.js"
      integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
      crossorigin="anonymous"
    ></script>
  </head>
  <body class="p-7">
    <div class="flex gap-6">
      <div class="w-1/3">
        <form
          class="flex justify-stretch gap-2 w-full"
          action="/form"
          method="post"
        >
          <input
            type="text"
            id="content"
            name="content"
            placeholder="Enter a Task"
            class="p-3 border-2 border-slate-400 rounded-md w-full"
          />
          <button
            class="bg-slate-900 px-4 py-2 text-slate-50 rounded-md"
            type="submit"
          >
            Add
          </button>
        </form>

        <ul class="space-y-5 py-5">
          {% for i in range(3) %}
          <li class="p-5 rounded-md shadow-sm border border-slate-100">
            This is take no {{ i + 0 }}
          </li>
          {% endfor %}
        </ul>
      </div>
      <div class="graph-container" id="graph-container">
        <svg class="border w-full h-full"></svg>
      </div>
    </div>

    <script>
            // Declare simulation globally
            var simulation;

              // Get the dimensions of the container
              var graphContainer = document.querySelector("#graph-container");
              var width = graphContainer.clientWidth;
              var height = graphContainer.clientHeight;

              // Apply these dimensions to your SVG
              var svg = d3
                .select("#graph-container svg")
                .attr("width", width)
                .attr("height", height);

              function generateGraph(inputNodes, inputLinks){
              // Convert the input data into d3's expected format
              var nodes = inputNodes.map((d) => Object.assign({}, d));
              var links = inputLinks.map((d) => Object.assign({}, d));

              // Create the simulation with nodes and links
              simulation = d3
                .forceSimulation(nodes)
                .force(
                  "link",
                  d3.forceLink(links).id((d) => d.id)
                )
                .force("charge", d3.forceManyBody())
                .force("center", d3.forceCenter(width / 2, height / 2));

              // Create the link lines
              var link = svg
                .append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("class", "link");

              // Create the node circles
              var node = svg
                .append("g")
                .attr("class", "nodes")
                .selectAll("circle")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("class", "node")
                .attr("r", 4)
                .call(
                  d3
                    .drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended)
                );

              // Define the radius for the nodes
              var radius = 4;

              // Update the simulation on each tick
               simulation.on("tick", () => {
          link
            .attr("x1", (d) => Math.max(radius, Math.min(width - radius, d.source.x)))
            .attr("y1", (d) => Math.max(radius, Math.min(height - radius, d.source.y)))
            .attr("x2", (d) => Math.max(radius, Math.min(width - radius, d.target.x)))
            .attr("y2", (d) => Math.max(radius, Math.min(height - radius, d.target.y)));

          // Keep the nodes inside the graph container
          node
            .attr("cx", (d) => d.x = Math.max(radius, Math.min(width - radius, d.x)))
            .attr("cy", (d) => d.y = Math.max(radius, Math.min(height - radius, d.y)));
        });
      }

            function dragstarted(event, d) {
              if (!event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
            }

            function dragged(event, d) {
              d.fx = event.x;
              d.fy = event.y;
            }

            function dragended(event, d) {
              if (!event.active) simulation.alphaTarget(-1);
              d.fx = null;
              d.fy = null;
            }

            // Assume graph_data is passed in correctly from Flask as JSON embedded in the HTML
            var graph_data = {{ graph_data | tojson | safe }};
            console.log(graph_data);
            generateGraph(graph_data.nodes, graph_data.links);
    </script>
    <script>
      $(document).ready(function () {
        $("form").on("submit", function (event) {
          event.preventDefault(); // Prevent the form from submitting via the browser.

          var formData = {
            content: $("input[name=content]").val(),
            tag: $("input[name=tag]").val(),
          };

          $.ajax({
            type: "POST",
            url: "/form",
            data: formData,
            dataType: "json",
            encode: true,
          })
            .done(function (data) {
              console.log(data);
              // Here you can also call a function to update the graph visualization
              // with the new node.
            })
            .fail(function (jqXHR, textStatus, errorThrown) {
              console.error("Error occurred: " + textStatus, errorThrown);
            });
        });
      });
    </script>
  </body>
</html>
